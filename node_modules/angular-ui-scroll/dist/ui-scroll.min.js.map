{"version":3,"sources":["webpack:///ui-scroll.min.js","webpack:///webpack/bootstrap 4a3e30973317185735be","webpack:///./src/ui-scroll.js","webpack:///./src/modules/jqLiteExtras.js","webpack:///./src/modules/elementRoutines.js","webpack:///./src/modules/buffer.js","webpack:///./src/modules/viewport.js","webpack:///./src/modules/padding.js","webpack:///./src/modules/adapter.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_jqLiteExtras","_jqLiteExtras2","_elementRoutines","_elementRoutines2","_buffer","_buffer2","_viewport","_viewport2","_adapter","_adapter2","angular","service","run","jqLiteExtras","window","jQuery","registerFor","element","directive","restrict","controller","scope","_this","this","container","viewport","forEach","children","child","tagName","toLowerCase","console","$injector","$rootScope","$timeout","$q","$parse","link","$scope","$attr","controllers","linker","parseNumericAttr","value","defaultValue","result","isNaN","defineProperty","datasource","propName","propUserName","descriptor","Object","getOwnPropertyDescriptor","set","get","indexStore","buffer","pending","length","topPaddingHeightOld","topDataPos","adjustPadding","adjustScrollTopAfterMinIndexSet","isInvalid","rid","ridActual","$$destroyed","bindEvents","bind","resizeAndScrollHandler","unbindEvents","unbind","reload","resetTopPadding","resetBottomPadding","arguments","startIndex","reset","adjustBuffer","isElementVisible","wrapper","height","offsetParent","visibilityWatcher","item","isFunction","unregisterVisibilityWatcher","insertWrapperContent","insertAfter","createElement","insertElement","$watch","addClass","promises","sibling","undefined","clone","itemName","adapter","transform","updateDOM","toBePrepended","toBeRemoved","inserted","i","op","unshift","push","concat","insertElementAnimated","remove","$index","first","prepended","removed","animated","updatePaddings","updates","all","then","enqueueFetch","shouldLoadBottom","effectiveHeight","fetch","loading","shouldLoadTop","w","removeClass","calculateProperties","adjustBufferAfterFetch","adjustScrollTopAfterPrepend","shift","fetchNext","bufferSize","eof","clipTop","append","fetchPrevious","bof","clipBottom","prepend","$$phase","isLoading","disabled","$apply","wheelHandler","event","scrollTop","yMax","scrollHeight","clientHeight","preventDefault","match","uiScroll","Error","BUFFER_MIN","BUFFER_DEFAULT","PADDING_MIN","PADDING_DEFAULT","datasourceName","viewportController","Math","max","padding","elementRoutines","isDatasourceValid","isObject","success","next","index","count","createPaddingElements","$destroy","$on","applyContainerStyle","require","transclude","priority","terminal","_classCallCheck","instance","Constructor","TypeError","_slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","_s","_i","Symbol","iterator","done","err","Array","isArray","_createClass","defineProperties","target","props","enumerable","configurable","writable","key","protoProps","staticProps","prototype","JQLiteExtras","scrollTo","self","direction","elem","_top$left$direction","top","left","method","prop","preserve","isWindow","isDefined","document","documentElement","getMeasurements","measure","base","borderA","borderB","computedMarginA","computedMarginB","computedStyle","dirA","dirB","marginA","marginB","paddingA","paddingB","width","border","margin","_width$height$measure","offsetWidth","offsetHeight","getStyle","convertToPx","getWidthHeight","measurements","outer","outerfull","style","parseFloat","css","name","nodeType","location","alert","setInterval","getComputedStyle","currentStyle","rs","rsLeft","core_pnum","source","rnumnonpx","RegExp","test","runtimeStyle","pixelLeft","before","newElem","j","parent","ref","contents","after","outerHTML","isNumber","outerHeight","option","outerWidth","offset","docElem","win","box","doc","ownerDocument","getBoundingClientRect","defaultView","parentWindow","pageYOffset","clientTop","pageXOffset","scrollLeft","clientLeft","_typeof","constructor","ElementRoutines","$animate","has","isAngularVersionLessThen1_3","version","major","minor","newElement","previousElement","_ret","deferred","defer","enter","resolve","v","promise","_this2","removeElement","_ret2","leave","ScrollBuffer","create","extend","size","minIndex","maxIndex","minIndexUser","maxIndexUser","items","insert","reverse","min","operation","splice","arg1","arg2","indexOf","removeElementAnimated","elements","Number","MAX_VALUE","bottom","MIN_VALUE","Viewport","bufferPadding","topPadding","bottomPadding","overflow-y","display","template","_padding2","bottomDataPos","bottomVisiblePos","topVisiblePos","e","overage","overageHeight","itemHeight","emptySpaceHeight","cache","add","topPaddingHeight","reduce","summ","bottomPaddingHeight","visibleItemsHeight","averageItemHeight","adjustTopPadding","adjustBottomPadding","topPaddingHeightAdd","bottomPaddingHeightAdd","diff","paddingHeight","clear","_padding","Cache","Padding","table","find","Adapter","createValueInjector","attribute","expression","viewportScope","assign","onControllerName","parseController","controllerName","on","candidate","candidateScope","candidateName","attr","hasOwnProperty","getPrototypeOf","controllerAsName","dotIndex","substr","applyUpdate","newItems","keepIt","pos","newItem","topVisibleInjector","topVisibleElementInjector","topVisibleScopeInjector","isLoadingInjector","isBOF","isEOF","isEmpty","applyUpdates","slice","itemTop","isNewRow","rowTop","topHeight"],"mappings":"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","file":"ui-scroll.min.js","sourcesContent":["/*!\r\n * angular-ui-scroll (uncompressed)\r\n * https://github.com/angular-ui/ui-scroll\r\n * Version: 1.6.0 -- 2017-02-04T09:24:37.966Z\r\n * License: MIT\r\n */\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _jqLiteExtras = __webpack_require__(1);\n\t\n\tvar _jqLiteExtras2 = _interopRequireDefault(_jqLiteExtras);\n\t\n\tvar _elementRoutines = __webpack_require__(2);\n\t\n\tvar _elementRoutines2 = _interopRequireDefault(_elementRoutines);\n\t\n\tvar _buffer = __webpack_require__(3);\n\t\n\tvar _buffer2 = _interopRequireDefault(_buffer);\n\t\n\tvar _viewport = __webpack_require__(4);\n\t\n\tvar _viewport2 = _interopRequireDefault(_viewport);\n\t\n\tvar _adapter = __webpack_require__(6);\n\t\n\tvar _adapter2 = _interopRequireDefault(_adapter);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tangular.module('ui.scroll', []).service('jqLiteExtras', function () {\n\t  return new _jqLiteExtras2.default();\n\t}).run(['jqLiteExtras', function (jqLiteExtras) {\n\t  return !window.jQuery ? jqLiteExtras.registerFor(angular.element) : null;\n\t}]).directive('uiScrollViewport', function () {\n\t  return {\n\t    restrict: 'A',\n\t    controller: ['$scope', '$element', function (scope, element) {\n\t      var _this = this;\n\t\n\t      this.container = element;\n\t      this.viewport = element;\n\t\n\t      angular.forEach(element.children(), function (child) {\n\t        if (child.tagName.toLowerCase() === 'tbody') {\n\t          _this.viewport = angular.element(child);\n\t        }\n\t      });\n\t\n\t      return this;\n\t    }]\n\t  };\n\t}).directive('uiScroll', ['$log', '$injector', '$rootScope', '$timeout', '$q', '$parse', function (console, $injector, $rootScope, $timeout, $q, $parse) {\n\t\n\t  return {\n\t    require: ['?^uiScrollViewport'],\n\t    restrict: 'A',\n\t    transclude: 'element',\n\t    priority: 1000,\n\t    terminal: true,\n\t    link: link\n\t  };\n\t\n\t  function link($scope, element, $attr, controllers, linker) {\n\t    var match = $attr.uiScroll.match(/^\\s*(\\w+)\\s+in\\s+([(\\w|\\$)\\.]+)\\s*$/);\n\t    if (!match) {\n\t      throw new Error('Expected uiScroll in form of \\'_item_ in _datasource_\\' but got \\'' + $attr.uiScroll + '\\'');\n\t    }\n\t\n\t    function parseNumericAttr(value, defaultValue) {\n\t      var result = $parse(value)($scope);\n\t      return isNaN(result) ? defaultValue : result;\n\t    }\n\t\n\t    var BUFFER_MIN = 3;\n\t    var BUFFER_DEFAULT = 10;\n\t    var PADDING_MIN = 0.3;\n\t    var PADDING_DEFAULT = 0.5;\n\t\n\t    var datasource = null;\n\t    var itemName = match[1];\n\t    var datasourceName = match[2];\n\t    var viewportController = controllers[0];\n\t    var bufferSize = Math.max(BUFFER_MIN, parseNumericAttr($attr.bufferSize, BUFFER_DEFAULT));\n\t    var padding = Math.max(PADDING_MIN, parseNumericAttr($attr.padding, PADDING_DEFAULT));\n\t    var startIndex = parseNumericAttr($attr.startIndex, 1);\n\t    var ridActual = 0; // current data revision id\n\t    var pending = [];\n\t\n\t    var elementRoutines = new _elementRoutines2.default($injector, $q);\n\t    var buffer = new _buffer2.default(elementRoutines, bufferSize);\n\t    var viewport = new _viewport2.default(elementRoutines, buffer, element, viewportController, padding);\n\t    var adapter = new _adapter2.default($rootScope, $parse, $attr, viewport, buffer, adjustBuffer, element);\n\t\n\t    if (viewportController) {\n\t      viewportController.adapter = adapter;\n\t    }\n\t\n\t    var isDatasourceValid = function isDatasourceValid() {\n\t      return angular.isObject(datasource) && angular.isFunction(datasource.get);\n\t    };\n\t    datasource = $parse(datasourceName)($scope); // try to get datasource on scope\n\t    if (!isDatasourceValid()) {\n\t      datasource = $injector.get(datasourceName); // try to inject datasource as service\n\t      if (!isDatasourceValid()) {\n\t        throw new Error(datasourceName + ' is not a valid datasource');\n\t      }\n\t    }\n\t\n\t    var indexStore = {};\n\t\n\t    function defineProperty(datasource, propName, propUserName) {\n\t      var descriptor = Object.getOwnPropertyDescriptor(datasource, propName);\n\t      if (!descriptor || !descriptor.set && !descriptor.get) {\n\t        Object.defineProperty(datasource, propName, {\n\t          set: function set(value) {\n\t            indexStore[propName] = value;\n\t            $timeout(function () {\n\t              buffer[propUserName] = value;\n\t              if (!pending.length) {\n\t                var topPaddingHeightOld = viewport.topDataPos();\n\t                viewport.adjustPadding();\n\t                if (propName === 'minIndex') {\n\t                  viewport.adjustScrollTopAfterMinIndexSet(topPaddingHeightOld);\n\t                }\n\t              }\n\t            });\n\t          },\n\t          get: function get() {\n\t            return indexStore[propName];\n\t          }\n\t        });\n\t      }\n\t    }\n\t\n\t    defineProperty(datasource, 'minIndex', 'minIndexUser');\n\t    defineProperty(datasource, 'maxIndex', 'maxIndexUser');\n\t\n\t    var fetchNext = datasource.get.length !== 2 ? function (success) {\n\t      return datasource.get(buffer.next, bufferSize, success);\n\t    } : function (success) {\n\t      datasource.get({\n\t        index: buffer.next,\n\t        append: buffer.length ? buffer[buffer.length - 1].item : void 0,\n\t        count: bufferSize\n\t      }, success);\n\t    };\n\t\n\t    var fetchPrevious = datasource.get.length !== 2 ? function (success) {\n\t      return datasource.get(buffer.first - bufferSize, bufferSize, success);\n\t    } : function (success) {\n\t      datasource.get({\n\t        index: buffer.first - bufferSize,\n\t        prepend: buffer.length ? buffer[0].item : void 0,\n\t        count: bufferSize\n\t      }, success);\n\t    };\n\t\n\t    adapter.reload = reload;\n\t\n\t    /**\n\t     * Build padding elements\n\t     *\n\t     * Calling linker is the only way I found to get access to the tag name of the template\n\t     * to prevent the directive scope from pollution a new scope is created and destroyed\n\t     * right after the builder creation is completed\n\t     */\n\t    linker(function (clone, scope) {\n\t      viewport.createPaddingElements(clone[0]);\n\t      // we do not include the clone in the DOM. It means that the nested directives will not\n\t      // be able to reach the parent directives, but in this case it is intentional because we\n\t      // created the clone to access the template tag name\n\t      scope.$destroy();\n\t      clone.remove();\n\t    });\n\t\n\t    $scope.$on('$destroy', function () {\n\t      unbindEvents();\n\t      viewport.unbind('mousewheel', wheelHandler);\n\t    });\n\t\n\t    viewport.bind('mousewheel', wheelHandler);\n\t\n\t    $timeout(function () {\n\t      viewport.applyContainerStyle();\n\t      reload();\n\t    });\n\t\n\t    /* Private function definitions */\n\t\n\t    function isInvalid(rid) {\n\t      return rid && rid !== ridActual || $scope.$$destroyed;\n\t    }\n\t\n\t    function bindEvents() {\n\t      viewport.bind('resize', resizeAndScrollHandler);\n\t      viewport.bind('scroll', resizeAndScrollHandler);\n\t    }\n\t\n\t    function unbindEvents() {\n\t      viewport.unbind('resize', resizeAndScrollHandler);\n\t      viewport.unbind('scroll', resizeAndScrollHandler);\n\t    }\n\t\n\t    function reload() {\n\t      viewport.resetTopPadding();\n\t      viewport.resetBottomPadding();\n\t      if (arguments.length) {\n\t        startIndex = arguments[0];\n\t      }\n\t      buffer.reset(startIndex);\n\t      adjustBuffer();\n\t    }\n\t\n\t    function isElementVisible(wrapper) {\n\t      return wrapper.element.height() && wrapper.element[0].offsetParent;\n\t    }\n\t\n\t    function visibilityWatcher(wrapper) {\n\t      if (isElementVisible(wrapper)) {\n\t        buffer.forEach(function (item) {\n\t          if (angular.isFunction(item.unregisterVisibilityWatcher)) {\n\t            item.unregisterVisibilityWatcher();\n\t            delete item.unregisterVisibilityWatcher;\n\t          }\n\t        });\n\t        adjustBuffer();\n\t      }\n\t    }\n\t\n\t    function insertWrapperContent(wrapper, insertAfter) {\n\t      createElement(wrapper, insertAfter, viewport.insertElement);\n\t      if (!isElementVisible(wrapper)) {\n\t        wrapper.unregisterVisibilityWatcher = wrapper.scope.$watch(function () {\n\t          return visibilityWatcher(wrapper);\n\t        });\n\t      }\n\t      wrapper.element.addClass('ng-hide'); // hide inserted elements before data binding\n\t    }\n\t\n\t    function createElement(wrapper, insertAfter, insertElement) {\n\t      var promises = null;\n\t      var sibling = insertAfter > 0 ? buffer[insertAfter - 1].element : undefined;\n\t      linker(function (clone, scope) {\n\t        promises = insertElement(clone, sibling);\n\t        wrapper.element = clone;\n\t        wrapper.scope = scope;\n\t        scope[itemName] = wrapper.item;\n\t      });\n\t      if (adapter.transform) adapter.transform(wrapper.scope, wrapper.element);\n\t      return promises;\n\t    }\n\t\n\t    function updateDOM() {\n\t      var promises = [];\n\t      var toBePrepended = [];\n\t      var toBeRemoved = [];\n\t      var inserted = [];\n\t\n\t      buffer.forEach(function (wrapper, i) {\n\t        switch (wrapper.op) {\n\t          case 'prepend':\n\t            toBePrepended.unshift(wrapper);\n\t            break;\n\t          case 'append':\n\t            insertWrapperContent(wrapper, i);\n\t            wrapper.op = 'none';\n\t            inserted.push(wrapper);\n\t            break;\n\t          case 'insert':\n\t            promises = promises.concat(createElement(wrapper, i, viewport.insertElementAnimated));\n\t            wrapper.op = 'none';\n\t            inserted.push(wrapper);\n\t            break;\n\t          case 'remove':\n\t            toBeRemoved.push(wrapper);\n\t        }\n\t      });\n\t\n\t      toBeRemoved.forEach(function (wrapper) {\n\t        return promises = promises.concat(buffer.remove(wrapper));\n\t      });\n\t\n\t      if (toBePrepended.length) toBePrepended.forEach(function (wrapper) {\n\t        insertWrapperContent(wrapper);\n\t        wrapper.op = 'none';\n\t      });\n\t\n\t      buffer.forEach(function (item, i) {\n\t        return item.scope.$index = buffer.first + i;\n\t      });\n\t\n\t      return {\n\t        prepended: toBePrepended,\n\t        removed: toBeRemoved,\n\t        inserted: inserted,\n\t        animated: promises\n\t      };\n\t    }\n\t\n\t    function updatePaddings(rid, updates) {\n\t      // schedule another adjustBuffer after animation completion\n\t      if (updates.animated.length) {\n\t        $q.all(updates.animated).then(function () {\n\t          viewport.adjustPadding();\n\t          adjustBuffer(rid);\n\t        });\n\t      } else {\n\t        viewport.adjustPadding();\n\t      }\n\t    }\n\t\n\t    function enqueueFetch(rid, updates) {\n\t      if (viewport.shouldLoadBottom()) {\n\t        if (!updates || buffer.effectiveHeight(updates.inserted) > 0) {\n\t          // this means that at least one item appended in the last batch has height > 0\n\t          if (pending.push(true) === 1) {\n\t            fetch(rid);\n\t            adapter.loading(true);\n\t          }\n\t        }\n\t      } else if (viewport.shouldLoadTop()) {\n\t        if (!updates || buffer.effectiveHeight(updates.prepended) > 0 || pending[0]) {\n\t          // this means that at least one item appended in the last batch has height > 0\n\t          // pending[0] = true means that previous fetch was appending. We need to force at least one prepend\n\t          // BTW there will always be at least 1 element in the pending array because bottom is fetched first\n\t          if (pending.push(false) === 1) {\n\t            fetch(rid);\n\t            adapter.loading(true);\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    function adjustBuffer(rid) {\n\t      if (!rid) {\n\t        // dismiss pending requests\n\t        pending = [];\n\t        rid = ++ridActual;\n\t      }\n\t\n\t      var updates = updateDOM();\n\t\n\t      // We need the item bindings to be processed before we can do adjustment\n\t      $timeout(function () {\n\t\n\t        // show elements after data binging has been done\n\t        updates.inserted.forEach(function (w) {\n\t          return w.element.removeClass('ng-hide');\n\t        });\n\t        updates.prepended.forEach(function (w) {\n\t          return w.element.removeClass('ng-hide');\n\t        });\n\t\n\t        if (isInvalid(rid)) {\n\t          return;\n\t        }\n\t\n\t        updatePaddings(rid, updates);\n\t        enqueueFetch(rid);\n\t\n\t        if (!pending.length) {\n\t          adapter.calculateProperties();\n\t        }\n\t      });\n\t    }\n\t\n\t    function adjustBufferAfterFetch(rid) {\n\t      var updates = updateDOM();\n\t\n\t      // We need the item bindings to be processed before we can do adjustment\n\t      $timeout(function () {\n\t\n\t        // show elements after data binging has been done\n\t        updates.inserted.forEach(function (w) {\n\t          return w.element.removeClass('ng-hide');\n\t        });\n\t        updates.prepended.forEach(function (w) {\n\t          return w.element.removeClass('ng-hide');\n\t        });\n\t\n\t        viewport.adjustScrollTopAfterPrepend(updates);\n\t\n\t        if (isInvalid(rid)) {\n\t          return;\n\t        }\n\t\n\t        updatePaddings(rid, updates);\n\t        enqueueFetch(rid, updates);\n\t        pending.shift();\n\t\n\t        if (pending.length) fetch(rid);else {\n\t          adapter.loading(false);\n\t          bindEvents();\n\t          adapter.calculateProperties();\n\t        }\n\t      });\n\t    }\n\t\n\t    function fetch(rid) {\n\t      if (pending[0]) {\n\t        // scrolling down\n\t        if (buffer.length && !viewport.shouldLoadBottom()) {\n\t          adjustBufferAfterFetch(rid);\n\t        } else {\n\t          fetchNext(function (result) {\n\t            if (isInvalid(rid)) {\n\t              return;\n\t            }\n\t\n\t            if (result.length < bufferSize) {\n\t              buffer.eof = true;\n\t            }\n\t\n\t            if (result.length > 0) {\n\t              viewport.clipTop();\n\t              buffer.append(result);\n\t            }\n\t\n\t            adjustBufferAfterFetch(rid);\n\t          });\n\t        }\n\t      } else {\n\t        // scrolling up\n\t        if (buffer.length && !viewport.shouldLoadTop()) {\n\t          adjustBufferAfterFetch(rid);\n\t        } else {\n\t          fetchPrevious(function (result) {\n\t            if (isInvalid(rid)) {\n\t              return;\n\t            }\n\t\n\t            if (result.length < bufferSize) {\n\t              buffer.bof = true;\n\t              // log 'bof is reached'\n\t            }\n\t\n\t            if (result.length > 0) {\n\t              if (buffer.length) {\n\t                viewport.clipBottom();\n\t              }\n\t              buffer.prepend(result);\n\t            }\n\t\n\t            adjustBufferAfterFetch(rid);\n\t          });\n\t        }\n\t      }\n\t    }\n\t\n\t    function resizeAndScrollHandler() {\n\t      if (!$rootScope.$$phase && !adapter.isLoading && !adapter.disabled) {\n\t\n\t        enqueueFetch(ridActual);\n\t\n\t        if (pending.length) {\n\t          unbindEvents();\n\t        } else {\n\t          adapter.calculateProperties();\n\t          $scope.$apply();\n\t        }\n\t      }\n\t    }\n\t\n\t    function wheelHandler(event) {\n\t      if (!adapter.disabled) {\n\t        var scrollTop = viewport[0].scrollTop;\n\t        var yMax = viewport[0].scrollHeight - viewport[0].clientHeight;\n\t\n\t        if (scrollTop === 0 && !buffer.bof || scrollTop === yMax && !buffer.eof) {\n\t          event.preventDefault();\n\t        }\n\t      }\n\t    }\n\t  }\n\t}]);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/*!\r\n\t globals: angular, window\r\n\t List of used element methods available in JQuery but not in JQuery Lite\r\n\t element.before(elem)\r\n\t element.height()\r\n\t element.outerHeight(true)\r\n\t element.height(value) = only for Top/Bottom padding elements\r\n\t element.scrollTop()\r\n\t element.scrollTop(value)\r\n\t */\n\t\n\tvar JQLiteExtras = function () {\n\t  function JQLiteExtras() {\n\t    _classCallCheck(this, JQLiteExtras);\n\t  }\n\t\n\t  _createClass(JQLiteExtras, [{\n\t    key: 'registerFor',\n\t    value: function registerFor(element) {\n\t      var convertToPx = void 0,\n\t          css = void 0,\n\t          getStyle = void 0,\n\t          isWindow = void 0;\n\t      // angular implementation blows up if elem is the window\n\t      css = angular.element.prototype.css;\n\t\n\t      element.prototype.css = function (name, value) {\n\t        var self = this;\n\t        var elem = self[0];\n\t        if (!(!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style)) {\n\t          return css.call(self, name, value);\n\t        }\n\t      };\n\t\n\t      // as defined in angularjs v1.0.5\n\t      isWindow = function isWindow(obj) {\n\t        return obj && obj.document && obj.location && obj.alert && obj.setInterval;\n\t      };\n\t\n\t      function scrollTo(self, direction, value) {\n\t        var elem = self[0];\n\t\n\t        var _top$left$direction = _slicedToArray({\n\t          top: ['scrollTop', 'pageYOffset', 'scrollLeft'],\n\t          left: ['scrollLeft', 'pageXOffset', 'scrollTop']\n\t        }[direction], 3),\n\t            method = _top$left$direction[0],\n\t            prop = _top$left$direction[1],\n\t            preserve = _top$left$direction[2];\n\t\n\t        if (isWindow(elem)) {\n\t          if (angular.isDefined(value)) {\n\t            return elem.scrollTo(self[preserve].call(self), value);\n\t          }\n\t          return prop in elem ? elem[prop] : elem.document.documentElement[method];\n\t        } else {\n\t          if (angular.isDefined(value)) {\n\t            elem[method] = value;\n\t          }\n\t          return elem[method];\n\t        }\n\t      }\n\t\n\t      if (window.getComputedStyle) {\n\t        getStyle = function getStyle(elem) {\n\t          return window.getComputedStyle(elem, null);\n\t        };\n\t        convertToPx = function convertToPx(elem, value) {\n\t          return parseFloat(value);\n\t        };\n\t      } else {\n\t        getStyle = function getStyle(elem) {\n\t          return elem.currentStyle;\n\t        };\n\t        convertToPx = function convertToPx(elem, value) {\n\t          var left = void 0,\n\t              result = void 0,\n\t              rs = void 0,\n\t              rsLeft = void 0,\n\t              style = void 0;\n\t          var core_pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source;\n\t          var rnumnonpx = new RegExp('^(' + core_pnum + ')(?!px)[a-z%]+$', 'i');\n\t\n\t          if (!rnumnonpx.test(value)) {\n\t            return parseFloat(value);\n\t          }\n\t\n\t          // ported from JQuery\n\t          style = elem.style;\n\t          left = style.left;\n\t          rs = elem.runtimeStyle;\n\t          rsLeft = rs && rs.left;\n\t          if (rs) {\n\t            rs.left = style.left;\n\t          }\n\t          // put in the new values to get a computed style out\n\t          style.left = value;\n\t          result = style.pixelLeft;\n\t          style.left = left;\n\t          if (rsLeft) {\n\t            rs.left = rsLeft;\n\t          }\n\t          return result;\n\t        };\n\t      }\n\t\n\t      function getMeasurements(elem, measure) {\n\t        var base = void 0,\n\t            borderA = void 0,\n\t            borderB = void 0,\n\t            computedMarginA = void 0,\n\t            computedMarginB = void 0,\n\t            computedStyle = void 0,\n\t            dirA = void 0,\n\t            dirB = void 0,\n\t            marginA = void 0,\n\t            marginB = void 0,\n\t            paddingA = void 0,\n\t            paddingB = void 0;\n\t\n\t        if (isWindow(elem)) {\n\t          base = document.documentElement[{ height: 'clientHeight', width: 'clientWidth' }[measure]];\n\t\n\t          return {\n\t            base: base,\n\t            padding: 0,\n\t            border: 0,\n\t            margin: 0\n\t          };\n\t        }\n\t\n\t        // Start with offset property\n\t\n\t        var _width$height$measure = _slicedToArray({\n\t          width: [elem.offsetWidth, 'Left', 'Right'],\n\t          height: [elem.offsetHeight, 'Top', 'Bottom']\n\t        }[measure], 3);\n\t\n\t        base = _width$height$measure[0];\n\t        dirA = _width$height$measure[1];\n\t        dirB = _width$height$measure[2];\n\t\n\t\n\t        computedStyle = getStyle(elem);\n\t        paddingA = convertToPx(elem, computedStyle['padding' + dirA]) || 0;\n\t        paddingB = convertToPx(elem, computedStyle['padding' + dirB]) || 0;\n\t        borderA = convertToPx(elem, computedStyle['border' + dirA + 'Width']) || 0;\n\t        borderB = convertToPx(elem, computedStyle['border' + dirB + 'Width']) || 0;\n\t        computedMarginA = computedStyle['margin' + dirA];\n\t        computedMarginB = computedStyle['margin' + dirB];\n\t\n\t        // I do not care for width for now, so this hack is irrelevant\n\t        // if ( !supportsPercentMargin )\n\t        // computedMarginA = hackPercentMargin( elem, computedStyle, computedMarginA )\n\t        // computedMarginB = hackPercentMargin( elem, computedStyle, computedMarginB )\n\t        marginA = convertToPx(elem, computedMarginA) || 0;\n\t        marginB = convertToPx(elem, computedMarginB) || 0;\n\t\n\t        return {\n\t          base: base,\n\t          padding: paddingA + paddingB,\n\t          border: borderA + borderB,\n\t          margin: marginA + marginB\n\t        };\n\t      }\n\t\n\t      function getWidthHeight(elem, direction, measure) {\n\t        var computedStyle = void 0,\n\t            result = void 0;\n\t\n\t        var measurements = getMeasurements(elem, direction);\n\t\n\t        if (measurements.base > 0) {\n\t          return {\n\t            base: measurements.base - measurements.padding - measurements.border,\n\t            outer: measurements.base,\n\t            outerfull: measurements.base + measurements.margin\n\t          }[measure];\n\t        }\n\t\n\t        // Fall back to computed then uncomputed css if necessary\n\t        computedStyle = getStyle(elem);\n\t        result = computedStyle[direction];\n\t\n\t        if (result < 0 || result === null) {\n\t          result = elem.style[direction] || 0;\n\t        }\n\t\n\t        // Normalize \"\", auto, and prepare for extra\n\t        result = parseFloat(result) || 0;\n\t\n\t        return {\n\t          base: result - measurements.padding - measurements.border,\n\t          outer: result,\n\t          outerfull: result + measurements.padding + measurements.border + measurements.margin\n\t        }[measure];\n\t      }\n\t\n\t      // define missing methods\n\t      return angular.forEach({\n\t        before: function before(newElem) {\n\t          var children, elem, i, j, parent, ref, self;\n\t          self = this;\n\t          elem = self[0];\n\t          parent = self.parent();\n\t          children = parent.contents();\n\t          if (children[0] === elem) {\n\t            return parent.prepend(newElem);\n\t          } else {\n\t            for (i = j = 1, ref = children.length - 1; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {\n\t              if (children[i] === elem) {\n\t                angular.element(children[i - 1]).after(newElem);\n\t                return;\n\t              }\n\t            }\n\t            throw new Error('invalid DOM structure ' + elem.outerHTML);\n\t          }\n\t        },\n\t        height: function height(value) {\n\t          var self;\n\t          self = this;\n\t          if (angular.isDefined(value)) {\n\t            if (angular.isNumber(value)) {\n\t              value = value + 'px';\n\t            }\n\t            return css.call(self, 'height', value);\n\t          } else {\n\t            return getWidthHeight(this[0], 'height', 'base');\n\t          }\n\t        },\n\t        outerHeight: function outerHeight(option) {\n\t          return getWidthHeight(this[0], 'height', option ? 'outerfull' : 'outer');\n\t        },\n\t        outerWidth: function outerWidth(option) {\n\t          return getWidthHeight(this[0], 'width', option ? 'outerfull' : 'outer');\n\t        },\n\t\n\t\n\t        /*\r\n\t         The offset setter method is not implemented\r\n\t         */\n\t        offset: function offset(value) {\n\t          var docElem = void 0,\n\t              win = void 0;\n\t          var self = this;\n\t          var box = {\n\t            top: 0,\n\t            left: 0\n\t          };\n\t          var elem = self[0];\n\t          var doc = elem && elem.ownerDocument;\n\t\n\t          if (arguments.length) {\n\t            if (value === undefined) {\n\t              return self;\n\t            }\n\t            // TODO: implement setter\n\t            throw new Error('offset setter method is not implemented');\n\t          }\n\t\n\t          if (!doc) {\n\t            return;\n\t          }\n\t\n\t          docElem = doc.documentElement;\n\t\n\t          // TODO: Make sure it's not a disconnected DOM node\n\t\n\t          if (elem.getBoundingClientRect != null) {\n\t            box = elem.getBoundingClientRect();\n\t          }\n\t\n\t          win = doc.defaultView || doc.parentWindow;\n\t\n\t          return {\n\t            top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),\n\t            left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)\n\t          };\n\t        },\n\t        scrollTop: function scrollTop(value) {\n\t          return scrollTo(this, 'top', value);\n\t        },\n\t        scrollLeft: function scrollLeft(value) {\n\t          return scrollTo(this, 'left', value);\n\t        }\n\t      }, function (value, key) {\n\t        if (!element.prototype[key]) {\n\t          return element.prototype[key] = value;\n\t        }\n\t      });\n\t    }\n\t  }]);\n\t\n\t  return JQLiteExtras;\n\t}();\n\t\n\texports.default = JQLiteExtras;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar ElementRoutines = function () {\n\t  function ElementRoutines($injector, $q) {\n\t    _classCallCheck(this, ElementRoutines);\n\t\n\t    this.$animate = $injector.has && $injector.has('$animate') ? $injector.get('$animate') : null;\n\t    this.isAngularVersionLessThen1_3 = angular.version.major === 1 && angular.version.minor < 3;\n\t    this.$q = $q;\n\t  }\n\t\n\t  _createClass(ElementRoutines, [{\n\t    key: 'insertElement',\n\t    value: function insertElement(newElement, previousElement) {\n\t      previousElement.after(newElement);\n\t      return [];\n\t    }\n\t  }, {\n\t    key: 'removeElement',\n\t    value: function removeElement(wrapper) {\n\t      wrapper.element.remove();\n\t      wrapper.scope.$destroy();\n\t      return [];\n\t    }\n\t  }, {\n\t    key: 'insertElementAnimated',\n\t    value: function insertElementAnimated(newElement, previousElement) {\n\t      var _this = this;\n\t\n\t      if (!this.$animate) {\n\t        return this.insertElement(newElement, previousElement);\n\t      }\n\t\n\t      if (this.isAngularVersionLessThen1_3) {\n\t        var _ret = function () {\n\t          var deferred = _this.$q.defer();\n\t          // no need for parent - previous element is never null\n\t          _this.$animate.enter(newElement, null, previousElement, function () {\n\t            return deferred.resolve();\n\t          });\n\t\n\t          return {\n\t            v: [deferred.promise]\n\t          };\n\t        }();\n\t\n\t        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n\t      }\n\t\n\t      // no need for parent - previous element is never null\n\t      return [this.$animate.enter(newElement, null, previousElement)];\n\t    }\n\t  }, {\n\t    key: 'removeElementAnimated',\n\t    value: function removeElementAnimated(wrapper) {\n\t      var _this2 = this;\n\t\n\t      if (!this.$animate) {\n\t        return this.removeElement(wrapper);\n\t      }\n\t\n\t      if (this.isAngularVersionLessThen1_3) {\n\t        var _ret2 = function () {\n\t          var deferred = _this2.$q.defer();\n\t          _this2.$animate.leave(wrapper.element, function () {\n\t            wrapper.scope.$destroy();\n\t            return deferred.resolve();\n\t          });\n\t\n\t          return {\n\t            v: [deferred.promise]\n\t          };\n\t        }();\n\t\n\t        if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n\t      }\n\t\n\t      return [this.$animate.leave(wrapper.element).then(function () {\n\t        return wrapper.scope.$destroy();\n\t      })];\n\t    }\n\t  }]);\n\t\n\t  return ElementRoutines;\n\t}();\n\t\n\texports.default = ElementRoutines;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = ScrollBuffer;\n\tfunction ScrollBuffer(elementRoutines, bufferSize) {\n\t  var buffer = Object.create(Array.prototype);\n\t\n\t  angular.extend(buffer, {\n\t    size: bufferSize,\n\t\n\t    reset: function reset(startIndex) {\n\t      buffer.remove(0, buffer.length);\n\t      buffer.eof = false;\n\t      buffer.bof = false;\n\t      buffer.first = startIndex;\n\t      buffer.next = startIndex;\n\t      buffer.minIndex = startIndex;\n\t      buffer.maxIndex = startIndex;\n\t      buffer.minIndexUser = null;\n\t      buffer.maxIndexUser = null;\n\t    },\n\t    append: function append(items) {\n\t      items.forEach(function (item) {\n\t        ++buffer.next;\n\t        buffer.insert('append', item);\n\t      });\n\t      buffer.maxIndex = buffer.eof ? buffer.next - 1 : Math.max(buffer.next - 1, buffer.maxIndex);\n\t    },\n\t    prepend: function prepend(items) {\n\t      items.reverse().forEach(function (item) {\n\t        --buffer.first;\n\t        buffer.insert('prepend', item);\n\t      });\n\t      buffer.minIndex = buffer.bof ? buffer.minIndex = buffer.first : Math.min(buffer.first, buffer.minIndex);\n\t    },\n\t\n\t\n\t    /**\r\n\t     * inserts wrapped element in the buffer\r\n\t     * the first argument is either operation keyword (see below) or a number for operation 'insert'\r\n\t     * for insert the number is the index for the buffer element the new one have to be inserted after\r\n\t     * operations: 'append', 'prepend', 'insert', 'remove', 'update', 'none'\r\n\t     */\n\t    insert: function insert(operation, item) {\n\t      var wrapper = {\n\t        item: item\n\t      };\n\t\n\t      if (operation % 1 === 0) {\n\t        // it is an insert\n\t        wrapper.op = 'insert';\n\t        buffer.splice(operation, 0, wrapper);\n\t      } else {\n\t        wrapper.op = operation;\n\t        switch (operation) {\n\t          case 'append':\n\t            buffer.push(wrapper);\n\t            break;\n\t          case 'prepend':\n\t            buffer.unshift(wrapper);\n\t            break;\n\t        }\n\t      }\n\t    },\n\t\n\t\n\t    // removes elements from buffer\n\t    remove: function remove(arg1, arg2) {\n\t      if (angular.isNumber(arg1)) {\n\t        // removes items from arg1 (including) through arg2 (excluding)\n\t        for (var i = arg1; i < arg2; i++) {\n\t          elementRoutines.removeElement(buffer[i]);\n\t        }\n\t\n\t        return buffer.splice(arg1, arg2 - arg1);\n\t      }\n\t      // removes single item(wrapper) from the buffer\n\t      buffer.splice(buffer.indexOf(arg1), 1);\n\t\n\t      return elementRoutines.removeElementAnimated(arg1);\n\t    },\n\t    effectiveHeight: function effectiveHeight(elements) {\n\t      if (!elements.length) {\n\t        return 0;\n\t      }\n\t      var top = Number.MAX_VALUE;\n\t      var bottom = Number.MIN_VALUE;\n\t      elements.forEach(function (wrapper) {\n\t        if (wrapper.element[0].offsetParent) {\n\t          // element style is not display:none\n\t          top = Math.min(top, wrapper.element.offset().top);\n\t          bottom = Math.max(bottom, wrapper.element.offset().top + wrapper.element.outerHeight(true));\n\t        }\n\t      });\n\t      return Math.max(0, bottom - top);\n\t    }\n\t  });\n\t\n\t  return buffer;\n\t}\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = Viewport;\n\t\n\tvar _padding = __webpack_require__(5);\n\t\n\tvar _padding2 = _interopRequireDefault(_padding);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction Viewport(elementRoutines, buffer, element, viewportController, padding) {\n\t  var topPadding = null;\n\t  var bottomPadding = null;\n\t  var viewport = viewportController && viewportController.viewport ? viewportController.viewport : angular.element(window);\n\t  var container = viewportController && viewportController.container ? viewportController.container : undefined;\n\t\n\t  viewport.css({\n\t    'overflow-y': 'auto',\n\t    'display': 'block'\n\t  });\n\t\n\t  function bufferPadding() {\n\t    return viewport.outerHeight() * padding; // some extra space to initiate preload\n\t  }\n\t\n\t  angular.extend(viewport, {\n\t    createPaddingElements: function createPaddingElements(template) {\n\t      topPadding = new _padding2.default(template);\n\t      bottomPadding = new _padding2.default(template);\n\t      element.before(topPadding);\n\t      element.after(bottomPadding);\n\t    },\n\t    applyContainerStyle: function applyContainerStyle() {\n\t      if (container && container !== viewport) {\n\t        viewport.css('height', window.getComputedStyle(container[0]).height);\n\t      }\n\t    },\n\t    bottomDataPos: function bottomDataPos() {\n\t      var scrollHeight = viewport[0].scrollHeight;\n\t      scrollHeight = scrollHeight != null ? scrollHeight : viewport[0].document.documentElement.scrollHeight;\n\t      return scrollHeight - bottomPadding.height();\n\t    },\n\t    topDataPos: function topDataPos() {\n\t      return topPadding.height();\n\t    },\n\t    bottomVisiblePos: function bottomVisiblePos() {\n\t      return viewport.scrollTop() + viewport.outerHeight();\n\t    },\n\t    topVisiblePos: function topVisiblePos() {\n\t      return viewport.scrollTop();\n\t    },\n\t    insertElement: function insertElement(e, sibling) {\n\t      return elementRoutines.insertElement(e, sibling || topPadding);\n\t    },\n\t    insertElementAnimated: function insertElementAnimated(e, sibling) {\n\t      return elementRoutines.insertElementAnimated(e, sibling || topPadding);\n\t    },\n\t    shouldLoadBottom: function shouldLoadBottom() {\n\t      return !buffer.eof && viewport.bottomDataPos() < viewport.bottomVisiblePos() + bufferPadding();\n\t    },\n\t    clipBottom: function clipBottom() {\n\t      // clip the invisible items off the bottom\n\t      var overage = 0;\n\t      var overageHeight = 0;\n\t      var itemHeight = 0;\n\t      var emptySpaceHeight = viewport.bottomDataPos() - viewport.bottomVisiblePos() - bufferPadding();\n\t\n\t      for (var i = buffer.length - 1; i >= 0; i--) {\n\t        itemHeight = buffer[i].element.outerHeight(true);\n\t        if (overageHeight + itemHeight > emptySpaceHeight) {\n\t          break;\n\t        }\n\t        bottomPadding.cache.add(buffer[i]);\n\t        overageHeight += itemHeight;\n\t        overage++;\n\t      }\n\t\n\t      if (overage > 0) {\n\t        buffer.eof = false;\n\t        buffer.remove(buffer.length - overage, buffer.length);\n\t        buffer.next -= overage;\n\t        viewport.adjustPadding();\n\t      }\n\t    },\n\t    shouldLoadTop: function shouldLoadTop() {\n\t      return !buffer.bof && viewport.topDataPos() > viewport.topVisiblePos() - bufferPadding();\n\t    },\n\t    clipTop: function clipTop() {\n\t      // clip the invisible items off the top\n\t      var overage = 0;\n\t      var overageHeight = 0;\n\t      var itemHeight = 0;\n\t      var emptySpaceHeight = viewport.topVisiblePos() - viewport.topDataPos() - bufferPadding();\n\t\n\t      for (var i = 0; i < buffer.length; i++) {\n\t        itemHeight = buffer[i].element.outerHeight(true);\n\t        if (overageHeight + itemHeight > emptySpaceHeight) {\n\t          break;\n\t        }\n\t        topPadding.cache.add(buffer[i]);\n\t        overageHeight += itemHeight;\n\t        overage++;\n\t      }\n\t\n\t      if (overage > 0) {\n\t        // we need to adjust top padding element before items are removed from top\n\t        // to avoid strange behaviour of scroll bar during remove top items when we are at the very bottom\n\t        topPadding.height(topPadding.height() + overageHeight);\n\t        buffer.bof = false;\n\t        buffer.remove(0, overage);\n\t        buffer.first += overage;\n\t      }\n\t    },\n\t    adjustPadding: function adjustPadding() {\n\t      if (!buffer.length) {\n\t        return;\n\t      }\n\t\n\t      // precise heights calculation, items that were in buffer once\n\t      var topPaddingHeight = topPadding.cache.reduce(function (summ, item) {\n\t        return summ + (item.index < buffer.first ? item.height : 0);\n\t      }, 0);\n\t      var bottomPaddingHeight = bottomPadding.cache.reduce(function (summ, item) {\n\t        return summ + (item.index >= buffer.next ? item.height : 0);\n\t      }, 0);\n\t\n\t      // average item height based on buffer data\n\t      var visibleItemsHeight = buffer.reduce(function (summ, item) {\n\t        return summ + item.element.outerHeight(true);\n\t      }, 0);\n\t      var averageItemHeight = (visibleItemsHeight + topPaddingHeight + bottomPaddingHeight) / (buffer.maxIndex - buffer.minIndex + 1);\n\t\n\t      // average heights calculation, items that have never been reached\n\t      var adjustTopPadding = buffer.minIndexUser !== null && buffer.minIndex > buffer.minIndexUser;\n\t      var adjustBottomPadding = buffer.maxIndexUser !== null && buffer.maxIndex < buffer.maxIndexUser;\n\t      var topPaddingHeightAdd = adjustTopPadding ? (buffer.minIndex - buffer.minIndexUser) * averageItemHeight : 0;\n\t      var bottomPaddingHeightAdd = adjustBottomPadding ? (buffer.maxIndexUser - buffer.maxIndex) * averageItemHeight : 0;\n\t\n\t      // paddings combine adjustment\n\t      topPadding.height(topPaddingHeight + topPaddingHeightAdd);\n\t      bottomPadding.height(bottomPaddingHeight + bottomPaddingHeightAdd);\n\t    },\n\t    adjustScrollTopAfterMinIndexSet: function adjustScrollTopAfterMinIndexSet(topPaddingHeightOld) {\n\t      // additional scrollTop adjustment in case of datasource.minIndex external set\n\t      if (buffer.minIndexUser !== null && buffer.minIndex > buffer.minIndexUser) {\n\t        var diff = topPadding.height() - topPaddingHeightOld;\n\t        viewport.scrollTop(viewport.scrollTop() + diff);\n\t      }\n\t    },\n\t    adjustScrollTopAfterPrepend: function adjustScrollTopAfterPrepend(updates) {\n\t      if (!updates.prepended.length) return;\n\t      var height = buffer.effectiveHeight(updates.prepended);\n\t      var paddingHeight = topPadding.height() - height;\n\t      if (paddingHeight >= 0) {\n\t        topPadding.height(paddingHeight);\n\t      } else {\n\t        topPadding.height(0);\n\t        viewport.scrollTop(viewport.scrollTop() - paddingHeight);\n\t      }\n\t    },\n\t    resetTopPadding: function resetTopPadding() {\n\t      topPadding.height(0);\n\t      topPadding.cache.clear();\n\t    },\n\t    resetBottomPadding: function resetBottomPadding() {\n\t      bottomPadding.height(0);\n\t      bottomPadding.cache.clear();\n\t    }\n\t  });\n\t\n\t  return viewport;\n\t}\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = Padding;\n\tfunction Cache() {\n\t  var cache = Object.create(Array.prototype);\n\t\n\t  angular.extend(cache, {\n\t    add: function add(item) {\n\t      for (var i = cache.length - 1; i >= 0; i--) {\n\t        if (cache[i].index === item.scope.$index) {\n\t          cache[i].height = item.element.outerHeight();\n\t          return;\n\t        }\n\t      }\n\t      cache.push({\n\t        index: item.scope.$index,\n\t        height: item.element.outerHeight()\n\t      });\n\t    },\n\t    clear: function clear() {\n\t      cache.length = 0;\n\t    }\n\t  });\n\t\n\t  return cache;\n\t}\n\t\n\tfunction Padding(template) {\n\t  var result = void 0;\n\t\n\t  switch (template.tagName) {\n\t    case 'dl':\n\t      throw new Error('ui-scroll directive does not support <' + template.tagName + '> as a repeating tag: ' + template.outerHTML);\n\t    case 'tr':\n\t      var table = angular.element('<table><tr><td><div></div></td></tr></table>');\n\t      result = table.find('tr');\n\t      break;\n\t    case 'li':\n\t      result = angular.element('<li></li>');\n\t      break;\n\t    default:\n\t      result = angular.element('<div></div>');\n\t  }\n\t\n\t  result.cache = new Cache();\n\t\n\t  return result;\n\t}\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = Adapter;\n\tfunction Adapter($rootScope, $parse, $attr, viewport, buffer, adjustBuffer, element) {\n\t  var viewportScope = viewport.scope() || $rootScope;\n\t  var disabled = false;\n\t  var self = this;\n\t\n\t  createValueInjector('adapter')(self);\n\t  var topVisibleInjector = createValueInjector('topVisible');\n\t  var topVisibleElementInjector = createValueInjector('topVisibleElement');\n\t  var topVisibleScopeInjector = createValueInjector('topVisibleScope');\n\t  var isLoadingInjector = createValueInjector('isLoading');\n\t\n\t  // Adapter API definition\n\t\n\t  Object.defineProperty(this, 'disabled', {\n\t    get: function get() {\n\t      return disabled;\n\t    },\n\t    set: function set(value) {\n\t      return !(disabled = value) ? adjustBuffer() : null;\n\t    }\n\t  });\n\t\n\t  this.isLoading = false;\n\t  this.isBOF = function () {\n\t    return buffer.bof;\n\t  };\n\t  this.isEOF = function () {\n\t    return buffer.eof;\n\t  };\n\t  this.isEmpty = function () {\n\t    return !buffer.length;\n\t  };\n\t\n\t  this.applyUpdates = function (arg1, arg2) {\n\t    if (angular.isFunction(arg1)) {\n\t      // arg1 is the updater function, arg2 is ignored\n\t      buffer.slice(0).forEach(function (wrapper) {\n\t        // we need to do it on the buffer clone, because buffer content\n\t        // may change as we iterate through\n\t        applyUpdate(wrapper, arg1(wrapper.item, wrapper.scope, wrapper.element));\n\t      });\n\t    } else {\n\t      // arg1 is item index, arg2 is the newItems array\n\t      if (arg1 % 1 !== 0) {\n\t        // checking if it is an integer\n\t        throw new Error('applyUpdates - ' + arg1 + ' is not a valid index');\n\t      }\n\t\n\t      var index = arg1 - buffer.first;\n\t      if (index >= 0 && index < buffer.length) {\n\t        applyUpdate(buffer[index], arg2);\n\t      }\n\t    }\n\t\n\t    adjustBuffer();\n\t  };\n\t\n\t  this.append = function (newItems) {\n\t    buffer.append(newItems);\n\t    adjustBuffer();\n\t  };\n\t\n\t  this.prepend = function (newItems) {\n\t    buffer.prepend(newItems);\n\t    adjustBuffer();\n\t  };\n\t\n\t  this.loading = function (value) {\n\t    isLoadingInjector(value);\n\t  };\n\t\n\t  this.calculateProperties = function () {\n\t    var item = void 0,\n\t        itemHeight = void 0,\n\t        itemTop = void 0,\n\t        isNewRow = void 0,\n\t        rowTop = null;\n\t    var topHeight = 0;\n\t    for (var i = 0; i < buffer.length; i++) {\n\t      item = buffer[i];\n\t      itemTop = item.element.offset().top;\n\t      isNewRow = rowTop !== itemTop;\n\t      rowTop = itemTop;\n\t      if (isNewRow) {\n\t        itemHeight = item.element.outerHeight(true);\n\t      }\n\t      if (isNewRow && viewport.topDataPos() + topHeight + itemHeight <= viewport.topVisiblePos()) {\n\t        topHeight += itemHeight;\n\t      } else {\n\t        if (isNewRow) {\n\t          topVisibleInjector(item.item);\n\t          topVisibleElementInjector(item.element);\n\t          topVisibleScopeInjector(item.scope);\n\t        }\n\t        break;\n\t      }\n\t    }\n\t  };\n\t\n\t  // private function definitions\n\t\n\t  function createValueInjector(attribute) {\n\t    var expression = $attr[attribute];\n\t    var scope = viewportScope;\n\t    var assign = void 0;\n\t    if (expression) {\n\t      // it is ok to have relaxed validation for the first part of the 'on' expression.\n\t      // additional validation will be done by the $parse service below\n\t      var match = expression.match(/^(\\S+)(?:\\s+on\\s+(\\w(?:\\w|\\d)*))?/);\n\t      if (!match) throw new Error('Expected injection expression in form of \\'target\\' or \\'target on controller\\' but got \\'' + expression + '\\'');\n\t      var target = match[1];\n\t      var onControllerName = match[2];\n\t\n\t      var parseController = function parseController(controllerName, on) {\n\t        var candidate = element;\n\t        while (candidate.length) {\n\t          var candidateScope = candidate.scope();\n\t          // ng-controller's \"Controller As\" parsing\n\t          var candidateName = (candidate.attr('ng-controller') || '').match(/(\\w(?:\\w|\\d)*)(?:\\s+as\\s+(\\w(?:\\w|\\d)*))?/);\n\t          if (candidateName && candidateName[on ? 1 : 2] === controllerName) {\n\t            scope = candidateScope;\n\t            return true;\n\t          }\n\t          // directive's/component's \"Controller As\" parsing\n\t          if (!on && candidateScope && candidateScope.hasOwnProperty(controllerName) && Object.getPrototypeOf(candidateScope[controllerName]).constructor.hasOwnProperty('$inject')) {\n\t            scope = candidateScope;\n\t            return true;\n\t          }\n\t          candidate = candidate.parent();\n\t        }\n\t      };\n\t\n\t      if (onControllerName) {\n\t        // 'on' syntax DOM parsing (adapter=\"adapter on ctrl\")\n\t        scope = null;\n\t        parseController(onControllerName, true);\n\t        if (!scope) {\n\t          throw new Error('Failed to locate target controller \\'' + onControllerName + '\\' to inject \\'' + target + '\\'');\n\t        }\n\t      } else {\n\t        // try to parse DOM with 'Controller As' syntax (adapter=\"ctrl.adapter\")\n\t        var controllerAsName = void 0;\n\t        var dotIndex = target.indexOf('.');\n\t        if (dotIndex > 0) {\n\t          controllerAsName = target.substr(0, dotIndex);\n\t          parseController(controllerAsName, false);\n\t        }\n\t      }\n\t\n\t      assign = $parse(target).assign;\n\t    }\n\t    return function (value) {\n\t      if (self !== value) // just to avoid injecting adapter reference in the adapter itself. Kludgy, I know.\n\t        self[attribute] = value;\n\t      if (assign) assign(scope, value);\n\t    };\n\t  }\n\t\n\t  function applyUpdate(wrapper, newItems) {\n\t    if (!angular.isArray(newItems)) {\n\t      return;\n\t    }\n\t\n\t    var keepIt = void 0;\n\t    var pos = buffer.indexOf(wrapper) + 1;\n\t\n\t    newItems.reverse().forEach(function (newItem) {\n\t      if (newItem === wrapper.item) {\n\t        keepIt = true;\n\t        pos--;\n\t      } else {\n\t        buffer.insert(pos, newItem);\n\t      }\n\t    });\n\t\n\t    if (!keepIt) {\n\t      wrapper.op = 'remove';\n\t    }\n\t  }\n\t}\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// ui-scroll.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 4a3e30973317185735be","import JQLiteExtras from './modules/jqLiteExtras';\nimport ElementRoutines from './modules/elementRoutines.js';\nimport ScrollBuffer from './modules/buffer.js';\nimport Viewport from './modules/viewport.js';\nimport Adapter from './modules/adapter.js';\n\nangular.module('ui.scroll', [])\n\n  .service('jqLiteExtras', () => new JQLiteExtras())\n  .run(['jqLiteExtras', (jqLiteExtras) =>\n    !window.jQuery ? jqLiteExtras.registerFor(angular.element) : null\n  ])\n\n  .directive('uiScrollViewport', function () {\n    return {\n      restrict: 'A',\n      controller: [\n        '$scope',\n        '$element',\n        function (scope, element) {\n          this.container = element;\n          this.viewport = element;\n\n          angular.forEach(element.children(), (child => {\n            if (child.tagName.toLowerCase() === 'tbody') {\n              this.viewport = angular.element(child);\n            }\n          }));\n\n          return this;\n        }\n      ]\n    };\n  })\n\n  .directive('uiScroll', [\n    '$log',\n    '$injector',\n    '$rootScope',\n    '$timeout',\n    '$q',\n    '$parse',\n    function (console, $injector, $rootScope, $timeout, $q, $parse) {\n\n      return {\n        require: ['?^uiScrollViewport'],\n        restrict: 'A',\n        transclude: 'element',\n        priority: 1000,\n        terminal: true,\n        link: link\n      };\n\n      function link($scope, element, $attr, controllers, linker) {\n        const match = $attr.uiScroll.match(/^\\s*(\\w+)\\s+in\\s+([(\\w|\\$)\\.]+)\\s*$/);\n        if (!match) {\n          throw new Error('Expected uiScroll in form of \\'_item_ in _datasource_\\' but got \\'' + $attr.uiScroll + '\\'');\n        }\n\n        function parseNumericAttr(value, defaultValue) {\n          let result = $parse(value)($scope);\n          return isNaN(result) ? defaultValue : result;\n        }\n\n        const BUFFER_MIN = 3;\n        const BUFFER_DEFAULT = 10;\n        const PADDING_MIN = 0.3;\n        const PADDING_DEFAULT = 0.5;\n\n        let datasource = null;\n        const itemName = match[1];\n        const datasourceName = match[2];\n        const viewportController = controllers[0];\n        const bufferSize = Math.max(BUFFER_MIN, parseNumericAttr($attr.bufferSize, BUFFER_DEFAULT));\n        const padding = Math.max(PADDING_MIN, parseNumericAttr($attr.padding, PADDING_DEFAULT));\n        let startIndex = parseNumericAttr($attr.startIndex, 1);\n        let ridActual = 0;// current data revision id\n        let pending = [];\n\n        let elementRoutines = new ElementRoutines($injector, $q);\n        let buffer = new ScrollBuffer(elementRoutines, bufferSize);\n        let viewport = new Viewport(elementRoutines, buffer, element, viewportController, padding);\n        let adapter = new Adapter($rootScope, $parse, $attr, viewport, buffer, adjustBuffer, element);\n\n        if (viewportController) {\n          viewportController.adapter = adapter;\n        }\n\n        let isDatasourceValid = () => angular.isObject(datasource) && angular.isFunction(datasource.get);\n        datasource = $parse(datasourceName)($scope); // try to get datasource on scope\n        if (!isDatasourceValid()) {\n          datasource = $injector.get(datasourceName); // try to inject datasource as service\n          if (!isDatasourceValid()) {\n            throw new Error(datasourceName + ' is not a valid datasource');\n          }\n        }\n\n        let indexStore = {};\n\n        function defineProperty(datasource, propName, propUserName) {\n          let descriptor = Object.getOwnPropertyDescriptor(datasource, propName);\n          if (!descriptor || (!descriptor.set && !descriptor.get)) {\n            Object.defineProperty(datasource, propName, {\n              set: (value) => {\n                indexStore[propName] = value;\n                $timeout(() => {\n                  buffer[propUserName] = value;\n                  if (!pending.length) {\n                    let topPaddingHeightOld = viewport.topDataPos();\n                    viewport.adjustPadding();\n                    if (propName === 'minIndex') {\n                      viewport.adjustScrollTopAfterMinIndexSet(topPaddingHeightOld);\n                    }\n                  }\n                });\n              },\n              get: () => indexStore[propName]\n            });\n          }\n        }\n\n        defineProperty(datasource, 'minIndex', 'minIndexUser');\n        defineProperty(datasource, 'maxIndex', 'maxIndexUser');\n\n        const fetchNext = (datasource.get.length !== 2) ? (success) => datasource.get(buffer.next, bufferSize, success)\n          : (success) => {\n          datasource.get({\n            index: buffer.next,\n            append: buffer.length ? buffer[buffer.length - 1].item : void 0,\n            count: bufferSize\n          }, success);\n        };\n\n        const fetchPrevious = (datasource.get.length !== 2) ? (success) => datasource.get(buffer.first - bufferSize, bufferSize, success)\n          : (success) => {\n          datasource.get({\n            index: buffer.first - bufferSize,\n            prepend: buffer.length ? buffer[0].item : void 0,\n            count: bufferSize\n          }, success);\n        };\n\n        adapter.reload = reload;\n\n        /**\n         * Build padding elements\n         *\n         * Calling linker is the only way I found to get access to the tag name of the template\n         * to prevent the directive scope from pollution a new scope is created and destroyed\n         * right after the builder creation is completed\n         */\n        linker((clone, scope) => {\n          viewport.createPaddingElements(clone[0]);\n          // we do not include the clone in the DOM. It means that the nested directives will not\n          // be able to reach the parent directives, but in this case it is intentional because we\n          // created the clone to access the template tag name\n          scope.$destroy();\n          clone.remove();\n        });\n\n        $scope.$on('$destroy', () => {\n          unbindEvents();\n          viewport.unbind('mousewheel', wheelHandler);\n        });\n\n        viewport.bind('mousewheel', wheelHandler);\n\n        $timeout(() => {\n          viewport.applyContainerStyle();\n          reload();\n        });\n\n        /* Private function definitions */\n\n        function isInvalid(rid) {\n          return (rid && rid !== ridActual) || $scope.$$destroyed;\n        }\n\n        function bindEvents() {\n          viewport.bind('resize', resizeAndScrollHandler);\n          viewport.bind('scroll', resizeAndScrollHandler);\n        }\n\n        function unbindEvents() {\n          viewport.unbind('resize', resizeAndScrollHandler);\n          viewport.unbind('scroll', resizeAndScrollHandler);\n        }\n\n        function reload() {\n          viewport.resetTopPadding();\n          viewport.resetBottomPadding();\n          if (arguments.length) {\n            startIndex = arguments[0];\n          }\n          buffer.reset(startIndex);\n          adjustBuffer();\n        }\n\n        function isElementVisible(wrapper) {\n          return wrapper.element.height() && wrapper.element[0].offsetParent;\n        }\n\n        function visibilityWatcher(wrapper) {\n          if (isElementVisible(wrapper)) {\n            buffer.forEach((item) => {\n              if (angular.isFunction(item.unregisterVisibilityWatcher)) {\n                item.unregisterVisibilityWatcher();\n                delete item.unregisterVisibilityWatcher;\n              }\n            });\n            adjustBuffer();\n          }\n        }\n\n        function insertWrapperContent(wrapper, insertAfter) {\n          createElement(wrapper, insertAfter, viewport.insertElement);\n          if (!isElementVisible(wrapper)) {\n            wrapper.unregisterVisibilityWatcher = wrapper.scope.$watch(() => visibilityWatcher(wrapper));\n          }\n          wrapper.element.addClass('ng-hide'); // hide inserted elements before data binding\n        }\n\n        function createElement(wrapper, insertAfter, insertElement) {\n          let promises = null;\n          let sibling = (insertAfter > 0) ? buffer[insertAfter - 1].element : undefined;\n          linker((clone, scope) => {\n            promises = insertElement(clone, sibling);\n            wrapper.element = clone;\n            wrapper.scope = scope;\n            scope[itemName] = wrapper.item;\n          });\n          if (adapter.transform)\n            adapter.transform(wrapper.scope, wrapper.element);\n          return promises;\n        }\n\n        function updateDOM() {\n          let promises = [];\n          const toBePrepended = [];\n          const toBeRemoved = [];\n          const inserted = [];\n\n          buffer.forEach((wrapper, i) => {\n            switch (wrapper.op) {\n              case 'prepend':\n                toBePrepended.unshift(wrapper);\n                break;\n              case 'append':\n                insertWrapperContent(wrapper, i);\n                wrapper.op = 'none';\n                inserted.push(wrapper);\n                break;\n              case 'insert':\n                promises = promises.concat(createElement(wrapper, i, viewport.insertElementAnimated));\n                wrapper.op = 'none';\n                inserted.push(wrapper);\n                break;\n              case 'remove':\n                toBeRemoved.push(wrapper);\n            }\n          });\n\n          toBeRemoved.forEach((wrapper) => promises = promises.concat(buffer.remove(wrapper)));\n\n          if (toBePrepended.length)\n            toBePrepended.forEach((wrapper) => {\n              insertWrapperContent(wrapper);\n              wrapper.op = 'none';\n            });\n\n          buffer.forEach((item, i) => item.scope.$index = buffer.first + i);\n\n          return {\n            prepended: toBePrepended,\n            removed: toBeRemoved,\n            inserted: inserted,\n            animated: promises\n          };\n\n        }\n\n        function updatePaddings(rid, updates) {\n          // schedule another adjustBuffer after animation completion\n          if (updates.animated.length) {\n            $q.all(updates.animated).then(() => {\n              viewport.adjustPadding();\n              adjustBuffer(rid);\n            });\n          } else {\n            viewport.adjustPadding();\n          }\n        }\n\n        function enqueueFetch(rid, updates) {\n          if (viewport.shouldLoadBottom()) {\n            if (!updates || buffer.effectiveHeight(updates.inserted) > 0) {\n              // this means that at least one item appended in the last batch has height > 0\n              if (pending.push(true) === 1) {\n                fetch(rid);\n                adapter.loading(true);\n              }\n            }\n          } else if (viewport.shouldLoadTop()) {\n            if ((!updates || buffer.effectiveHeight(updates.prepended) > 0) || pending[0]) {\n              // this means that at least one item appended in the last batch has height > 0\n              // pending[0] = true means that previous fetch was appending. We need to force at least one prepend\n              // BTW there will always be at least 1 element in the pending array because bottom is fetched first\n              if (pending.push(false) === 1) {\n                fetch(rid);\n                adapter.loading(true);\n              }\n            }\n          }\n        }\n\n        function adjustBuffer(rid) {\n          if (!rid) { // dismiss pending requests\n            pending = [];\n            rid = ++ridActual;\n          }\n\n          let updates = updateDOM();\n\n          // We need the item bindings to be processed before we can do adjustment\n          $timeout(() => {\n\n            // show elements after data binging has been done\n            updates.inserted.forEach(w => w.element.removeClass('ng-hide'));\n            updates.prepended.forEach(w => w.element.removeClass('ng-hide'));\n\n            if (isInvalid(rid)) {\n              return;\n            }\n\n            updatePaddings(rid, updates);\n            enqueueFetch(rid);\n\n            if (!pending.length) {\n              adapter.calculateProperties();\n            }\n          });\n        }\n\n        function adjustBufferAfterFetch(rid) {\n          let updates = updateDOM();\n\n          // We need the item bindings to be processed before we can do adjustment\n          $timeout(() => {\n\n            // show elements after data binging has been done\n            updates.inserted.forEach(w => w.element.removeClass('ng-hide'));\n            updates.prepended.forEach(w => w.element.removeClass('ng-hide'));\n\n            viewport.adjustScrollTopAfterPrepend(updates);\n\n            if (isInvalid(rid)) {\n              return;\n            }\n\n            updatePaddings(rid, updates);\n            enqueueFetch(rid, updates);\n            pending.shift();\n\n            if (pending.length)\n              fetch(rid);\n            else {\n              adapter.loading(false);\n              bindEvents();\n              adapter.calculateProperties();\n            }\n          });\n        }\n\n        function fetch(rid) {\n          if (pending[0]) {// scrolling down\n            if (buffer.length && !viewport.shouldLoadBottom()) {\n              adjustBufferAfterFetch(rid);\n            } else {\n              fetchNext((result) => {\n                if (isInvalid(rid)) {\n                  return;\n                }\n\n                if (result.length < bufferSize) {\n                  buffer.eof = true;\n                }\n\n                if (result.length > 0) {\n                  viewport.clipTop();\n                  buffer.append(result);\n                }\n\n                adjustBufferAfterFetch(rid);\n              });\n            }\n          } else {  // scrolling up\n            if (buffer.length && !viewport.shouldLoadTop()) {\n              adjustBufferAfterFetch(rid);\n            } else {\n              fetchPrevious((result) => {\n                if (isInvalid(rid)) {\n                  return;\n                }\n\n                if (result.length < bufferSize) {\n                  buffer.bof = true;\n                  // log 'bof is reached'\n                }\n\n                if (result.length > 0) {\n                  if (buffer.length) {\n                    viewport.clipBottom();\n                  }\n                  buffer.prepend(result);\n                }\n\n                adjustBufferAfterFetch(rid);\n              });\n            }\n          }\n        }\n\n        function resizeAndScrollHandler() {\n          if (!$rootScope.$$phase && !adapter.isLoading && !adapter.disabled) {\n\n            enqueueFetch(ridActual);\n\n            if (pending.length) {\n              unbindEvents();\n            } else {\n              adapter.calculateProperties();\n              $scope.$apply();\n            }\n          }\n        }\n\n        function wheelHandler(event) {\n          if (!adapter.disabled) {\n            let scrollTop = viewport[0].scrollTop;\n            let yMax = viewport[0].scrollHeight - viewport[0].clientHeight;\n\n            if ((scrollTop === 0 && !buffer.bof) || (scrollTop === yMax && !buffer.eof)) {\n              event.preventDefault();\n            }\n          }\n        }\n      }\n\n    }\n  ]);\n\n\n// WEBPACK FOOTER //\n// ./src/ui-scroll.js","/*!\r\n globals: angular, window\r\n List of used element methods available in JQuery but not in JQuery Lite\r\n element.before(elem)\r\n element.height()\r\n element.outerHeight(true)\r\n element.height(value) = only for Top/Bottom padding elements\r\n element.scrollTop()\r\n element.scrollTop(value)\r\n */\r\n\r\nexport default class JQLiteExtras {\r\n\r\n  registerFor(element) {\r\n    let convertToPx, css, getStyle, isWindow;\r\n    // angular implementation blows up if elem is the window\r\n    css = angular.element.prototype.css;\r\n\r\n    element.prototype.css = function (name, value) {\r\n      let self = this;\r\n      let elem = self[0];\r\n      if (!(!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style)) {\r\n        return css.call(self, name, value);\r\n      }\r\n    };\r\n\r\n    // as defined in angularjs v1.0.5\r\n    isWindow = (obj) => obj && obj.document && obj.location && obj.alert && obj.setInterval;\r\n\r\n    function scrollTo(self, direction, value) {\r\n      let elem = self[0];\r\n      let [method, prop, preserve] = {\r\n        top: [\r\n          'scrollTop',\r\n          'pageYOffset',\r\n          'scrollLeft'\r\n        ],\r\n        left: [\r\n          'scrollLeft',\r\n          'pageXOffset',\r\n          'scrollTop'\r\n        ]\r\n      }[direction];\r\n\r\n      if (isWindow(elem)) {\r\n        if (angular.isDefined(value)) {\r\n          return elem.scrollTo(self[preserve].call(self), value);\r\n        }\r\n        return (prop in elem) ? elem[prop] : elem.document.documentElement[method];\r\n      } else {\r\n        if (angular.isDefined(value)) {\r\n          elem[method] = value;\r\n        }\r\n        return elem[method];\r\n      }\r\n    }\r\n\r\n    if (window.getComputedStyle) {\r\n      getStyle = (elem) => window.getComputedStyle(elem, null);\r\n      convertToPx = (elem, value) => parseFloat(value);\r\n    } else {\r\n      getStyle = (elem) => elem.currentStyle;\r\n      convertToPx = (elem, value) => {\r\n        let left, result, rs, rsLeft, style;\r\n        let core_pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source;\r\n        let rnumnonpx = new RegExp('^(' + core_pnum + ')(?!px)[a-z%]+$', 'i');\r\n\r\n        if (!rnumnonpx.test(value)) {\r\n          return parseFloat(value);\r\n        }\r\n\r\n        // ported from JQuery\r\n        style = elem.style;\r\n        left = style.left;\r\n        rs = elem.runtimeStyle;\r\n        rsLeft = rs && rs.left;\r\n        if (rs) {\r\n          rs.left = style.left;\r\n        }\r\n        // put in the new values to get a computed style out\r\n        style.left = value;\r\n        result = style.pixelLeft;\r\n        style.left = left;\r\n        if (rsLeft) {\r\n          rs.left = rsLeft;\r\n        }\r\n        return result;\r\n      };\r\n    }\r\n\r\n    function getMeasurements(elem, measure) {\r\n      let base, borderA, borderB, computedMarginA, computedMarginB, computedStyle, dirA, dirB, marginA, marginB, paddingA, paddingB;\r\n\r\n      if (isWindow(elem)) {\r\n        base = document.documentElement[{height: 'clientHeight', width: 'clientWidth'}[measure]];\r\n\r\n        return {\r\n          base: base,\r\n          padding: 0,\r\n          border: 0,\r\n          margin: 0\r\n        };\r\n      }\r\n\r\n      // Start with offset property\r\n      [\r\n        base,\r\n        dirA,\r\n        dirB\r\n      ] = {\r\n        width: [\r\n          elem.offsetWidth,\r\n          'Left',\r\n          'Right'\r\n        ],\r\n        height: [\r\n          elem.offsetHeight,\r\n          'Top',\r\n          'Bottom'\r\n        ]\r\n      }[measure];\r\n\r\n      computedStyle = getStyle(elem);\r\n      paddingA = convertToPx(elem, computedStyle['padding' + dirA]) || 0;\r\n      paddingB = convertToPx(elem, computedStyle['padding' + dirB]) || 0;\r\n      borderA = convertToPx(elem, computedStyle['border' + dirA + 'Width']) || 0;\r\n      borderB = convertToPx(elem, computedStyle['border' + dirB + 'Width']) || 0;\r\n      computedMarginA = computedStyle['margin' + dirA];\r\n      computedMarginB = computedStyle['margin' + dirB];\r\n\r\n      // I do not care for width for now, so this hack is irrelevant\r\n      // if ( !supportsPercentMargin )\r\n      // computedMarginA = hackPercentMargin( elem, computedStyle, computedMarginA )\r\n      // computedMarginB = hackPercentMargin( elem, computedStyle, computedMarginB )\r\n      marginA = convertToPx(elem, computedMarginA) || 0;\r\n      marginB = convertToPx(elem, computedMarginB) || 0;\r\n\r\n      return {\r\n        base: base,\r\n        padding: paddingA + paddingB,\r\n        border: borderA + borderB,\r\n        margin: marginA + marginB\r\n      };\r\n    }\r\n\r\n    function getWidthHeight(elem, direction, measure) {\r\n      let computedStyle, result;\r\n\r\n      let measurements = getMeasurements(elem, direction);\r\n\r\n      if (measurements.base > 0) {\r\n        return {\r\n          base: measurements.base - measurements.padding - measurements.border,\r\n          outer: measurements.base,\r\n          outerfull: measurements.base + measurements.margin\r\n        }[measure];\r\n      }\r\n\r\n      // Fall back to computed then uncomputed css if necessary\r\n      computedStyle = getStyle(elem);\r\n      result = computedStyle[direction];\r\n\r\n      if (result < 0 || result === null) {\r\n        result = elem.style[direction] || 0;\r\n      }\r\n\r\n      // Normalize \"\", auto, and prepare for extra\r\n      result = parseFloat(result) || 0;\r\n\r\n      return {\r\n        base: result - measurements.padding - measurements.border,\r\n        outer: result,\r\n        outerfull: result + measurements.padding + measurements.border + measurements.margin\r\n      }[measure];\r\n    }\r\n\r\n    // define missing methods\r\n    return angular.forEach({\r\n      before(newElem) {\r\n        var children, elem, i, j, parent, ref, self;\r\n        self = this;\r\n        elem = self[0];\r\n        parent = self.parent();\r\n        children = parent.contents();\r\n        if (children[0] === elem) {\r\n          return parent.prepend(newElem);\r\n        } else {\r\n          for (i = j = 1, ref = children.length - 1; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {\r\n            if (children[i] === elem) {\r\n              angular.element(children[i - 1]).after(newElem);\r\n              return;\r\n            }\r\n          }\r\n          throw new Error('invalid DOM structure ' + elem.outerHTML);\r\n        }\r\n      },\r\n      height (value){\r\n        var self;\r\n        self = this;\r\n        if (angular.isDefined(value)) {\r\n          if (angular.isNumber(value)) {\r\n            value = value + 'px';\r\n          }\r\n          return css.call(self, 'height', value);\r\n        } else {\r\n          return getWidthHeight(this[0], 'height', 'base');\r\n        }\r\n      },\r\n      outerHeight(option) {\r\n        return getWidthHeight(this[0], 'height', option ? 'outerfull' : 'outer');\r\n      },\r\n      outerWidth(option) {\r\n        return getWidthHeight(this[0], 'width', option ? 'outerfull' : 'outer');\r\n      },\r\n\r\n      /*\r\n       The offset setter method is not implemented\r\n       */\r\n      offset(value) {\r\n        let docElem, win;\r\n        let self = this;\r\n        let box = {\r\n          top: 0,\r\n          left: 0\r\n        };\r\n        let elem = self[0];\r\n        let doc = elem && elem.ownerDocument;\r\n\r\n        if (arguments.length) {\r\n          if (value === undefined) {\r\n            return self;\r\n          }\r\n          // TODO: implement setter\r\n          throw new Error('offset setter method is not implemented');\r\n        }\r\n\r\n        if (!doc) {\r\n          return;\r\n        }\r\n\r\n        docElem = doc.documentElement;\r\n\r\n        // TODO: Make sure it's not a disconnected DOM node\r\n\r\n        if (elem.getBoundingClientRect != null) {\r\n          box = elem.getBoundingClientRect();\r\n        }\r\n\r\n        win = doc.defaultView || doc.parentWindow;\r\n\r\n        return {\r\n          top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),\r\n          left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)\r\n        };\r\n      },\r\n      scrollTop(value) {\r\n        return scrollTo(this, 'top', value);\r\n      },\r\n      scrollLeft(value) {\r\n        return scrollTo(this, 'left', value);\r\n      }\r\n    }, (value, key) => {\r\n      if (!element.prototype[key]) {\r\n        return element.prototype[key] = value;\r\n      }\r\n    });\r\n  }\r\n\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/modules/jqLiteExtras.js","export default class ElementRoutines {\r\n\r\n  constructor($injector, $q) {\r\n    this.$animate = ($injector.has && $injector.has('$animate')) ? $injector.get('$animate') : null;\r\n    this.isAngularVersionLessThen1_3 = angular.version.major === 1 && angular.version.minor < 3;\r\n    this.$q = $q;\r\n  }\r\n\r\n  insertElement(newElement, previousElement) {\r\n    previousElement.after(newElement);\r\n    return [];\r\n  }\r\n\r\n  removeElement(wrapper) {\r\n    wrapper.element.remove();\r\n    wrapper.scope.$destroy();\r\n    return [];\r\n  }\r\n\r\n  insertElementAnimated(newElement, previousElement) {\r\n    if (!this.$animate) {\r\n      return this.insertElement(newElement, previousElement);\r\n    }\r\n\r\n    if (this.isAngularVersionLessThen1_3) {\r\n      const deferred = this.$q.defer();\r\n      // no need for parent - previous element is never null\r\n      this.$animate.enter(newElement, null, previousElement, () => deferred.resolve());\r\n\r\n      return [deferred.promise];\r\n    }\r\n\r\n    // no need for parent - previous element is never null\r\n    return [this.$animate.enter(newElement, null, previousElement)];\r\n  }\r\n\r\n  removeElementAnimated(wrapper) {\r\n    if (!this.$animate) {\r\n      return this.removeElement(wrapper);\r\n    }\r\n\r\n    if (this.isAngularVersionLessThen1_3) {\r\n      const deferred = this.$q.defer();\r\n      this.$animate.leave(wrapper.element, () => {\r\n        wrapper.scope.$destroy();\r\n        return deferred.resolve();\r\n      });\r\n\r\n      return [deferred.promise];\r\n    }\r\n\r\n    return [(this.$animate.leave(wrapper.element)).then(() => wrapper.scope.$destroy())];\r\n  }\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/modules/elementRoutines.js","export default function ScrollBuffer(elementRoutines, bufferSize) {\r\n  const buffer = Object.create(Array.prototype);\r\n\r\n  angular.extend(buffer, {\r\n    size: bufferSize,\r\n\r\n    reset(startIndex) {\r\n      buffer.remove(0, buffer.length);\r\n      buffer.eof = false;\r\n      buffer.bof = false;\r\n      buffer.first = startIndex;\r\n      buffer.next = startIndex;\r\n      buffer.minIndex = startIndex;\r\n      buffer.maxIndex = startIndex;\r\n      buffer.minIndexUser = null;\r\n      buffer.maxIndexUser = null;\r\n    },\r\n\r\n    append(items) {\r\n      items.forEach((item) => {\r\n        ++buffer.next;\r\n        buffer.insert('append', item);\r\n      });\r\n      buffer.maxIndex = buffer.eof ? buffer.next - 1 : Math.max(buffer.next - 1, buffer.maxIndex);\r\n    },\r\n\r\n    prepend(items) {\r\n      items.reverse().forEach((item) => {\r\n        --buffer.first;\r\n        buffer.insert('prepend', item);\r\n      });\r\n      buffer.minIndex = buffer.bof ? buffer.minIndex = buffer.first : Math.min(buffer.first, buffer.minIndex);\r\n    },\r\n\r\n    /**\r\n     * inserts wrapped element in the buffer\r\n     * the first argument is either operation keyword (see below) or a number for operation 'insert'\r\n     * for insert the number is the index for the buffer element the new one have to be inserted after\r\n     * operations: 'append', 'prepend', 'insert', 'remove', 'update', 'none'\r\n     */\r\n    insert(operation, item) {\r\n      const wrapper = {\r\n        item: item\r\n      };\r\n\r\n      if (operation % 1 === 0) {// it is an insert\r\n        wrapper.op = 'insert';\r\n        buffer.splice(operation, 0, wrapper);\r\n      } else {\r\n        wrapper.op = operation;\r\n        switch (operation) {\r\n          case 'append':\r\n            buffer.push(wrapper);\r\n            break;\r\n          case 'prepend':\r\n            buffer.unshift(wrapper);\r\n            break;\r\n        }\r\n      }\r\n    },\r\n\r\n    // removes elements from buffer\r\n    remove(arg1, arg2) {\r\n      if (angular.isNumber(arg1)) {\r\n        // removes items from arg1 (including) through arg2 (excluding)\r\n        for (let i = arg1; i < arg2; i++) {\r\n          elementRoutines.removeElement(buffer[i]);\r\n        }\r\n\r\n        return buffer.splice(arg1, arg2 - arg1);\r\n      }\r\n      // removes single item(wrapper) from the buffer\r\n      buffer.splice(buffer.indexOf(arg1), 1);\r\n\r\n      return elementRoutines.removeElementAnimated(arg1);\r\n    },\r\n\r\n    effectiveHeight(elements) {\r\n      if (!elements.length) {\r\n        return 0;\r\n      }\r\n      let top = Number.MAX_VALUE;\r\n      let bottom = Number.MIN_VALUE;\r\n      elements.forEach((wrapper) => {\r\n        if (wrapper.element[0].offsetParent) {\r\n          // element style is not display:none\r\n          top = Math.min(top, wrapper.element.offset().top);\r\n          bottom = Math.max(bottom, wrapper.element.offset().top + wrapper.element.outerHeight(true));\r\n        }\r\n      });\r\n      return Math.max(0, bottom - top);\r\n    }\r\n\r\n  });\r\n\r\n  return buffer;\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/modules/buffer.js","import Padding from './padding';\r\n\r\nexport default function Viewport(elementRoutines, buffer, element, viewportController, padding) {\r\n  let topPadding = null;\r\n  let bottomPadding = null;\r\n  const viewport = viewportController && viewportController.viewport ? viewportController.viewport : angular.element(window);\r\n  const container = viewportController && viewportController.container ? viewportController.container : undefined;\r\n\r\n  viewport.css({\r\n    'overflow-y': 'auto',\r\n    'display': 'block'\r\n  });\r\n\r\n  function bufferPadding() {\r\n    return viewport.outerHeight() * padding; // some extra space to initiate preload\r\n  }\r\n\r\n  angular.extend(viewport, {\r\n    createPaddingElements(template) {\r\n      topPadding = new Padding(template);\r\n      bottomPadding = new Padding(template);\r\n      element.before(topPadding);\r\n      element.after(bottomPadding);\r\n    },\r\n\r\n    applyContainerStyle() {\r\n      if (container && container !== viewport) {\r\n        viewport.css('height', window.getComputedStyle(container[0]).height);\r\n      }\r\n    },\r\n\r\n    bottomDataPos() {\r\n      let scrollHeight = viewport[0].scrollHeight;\r\n      scrollHeight = scrollHeight != null ? scrollHeight : viewport[0].document.documentElement.scrollHeight;\r\n      return scrollHeight - bottomPadding.height();\r\n    },\r\n\r\n    topDataPos() {\r\n      return topPadding.height();\r\n    },\r\n\r\n    bottomVisiblePos() {\r\n      return viewport.scrollTop() + viewport.outerHeight();\r\n    },\r\n\r\n    topVisiblePos() {\r\n      return viewport.scrollTop();\r\n    },\r\n\r\n    insertElement(e, sibling) {\r\n      return elementRoutines.insertElement(e, sibling || topPadding);\r\n    },\r\n\r\n    insertElementAnimated(e, sibling) {\r\n      return elementRoutines.insertElementAnimated(e, sibling || topPadding);\r\n    },\r\n\r\n    shouldLoadBottom() {\r\n      return !buffer.eof && viewport.bottomDataPos() < viewport.bottomVisiblePos() + bufferPadding();\r\n    },\r\n\r\n    clipBottom() {\r\n      // clip the invisible items off the bottom\r\n      let overage = 0;\r\n      let overageHeight = 0;\r\n      let itemHeight = 0;\r\n      let emptySpaceHeight = viewport.bottomDataPos() - viewport.bottomVisiblePos() - bufferPadding();\r\n\r\n      for (let i = buffer.length - 1; i >= 0; i--) {\r\n        itemHeight = buffer[i].element.outerHeight(true);\r\n        if (overageHeight + itemHeight > emptySpaceHeight) {\r\n          break;\r\n        }\r\n        bottomPadding.cache.add(buffer[i]);\r\n        overageHeight += itemHeight;\r\n        overage++;\r\n      }\r\n\r\n      if (overage > 0) {\r\n        buffer.eof = false;\r\n        buffer.remove(buffer.length - overage, buffer.length);\r\n        buffer.next -= overage;\r\n        viewport.adjustPadding();\r\n      }\r\n    },\r\n\r\n    shouldLoadTop() {\r\n      return !buffer.bof && (viewport.topDataPos() > viewport.topVisiblePos() - bufferPadding());\r\n    },\r\n\r\n    clipTop() {\r\n      // clip the invisible items off the top\r\n      let overage = 0;\r\n      let overageHeight = 0;\r\n      let itemHeight = 0;\r\n      let emptySpaceHeight = viewport.topVisiblePos() - viewport.topDataPos() - bufferPadding();\r\n\r\n      for (let i = 0; i < buffer.length; i++) {\r\n        itemHeight = buffer[i].element.outerHeight(true);\r\n        if (overageHeight + itemHeight > emptySpaceHeight) {\r\n          break;\r\n        }\r\n        topPadding.cache.add(buffer[i]);\r\n        overageHeight += itemHeight;\r\n        overage++;\r\n      }\r\n\r\n      if (overage > 0) {\r\n        // we need to adjust top padding element before items are removed from top\r\n        // to avoid strange behaviour of scroll bar during remove top items when we are at the very bottom\r\n        topPadding.height(topPadding.height() + overageHeight);\r\n        buffer.bof = false;\r\n        buffer.remove(0, overage);\r\n        buffer.first += overage;\r\n      }\r\n    },\r\n\r\n    adjustPadding() {\r\n      if (!buffer.length) {\r\n        return;\r\n      }\r\n\r\n      // precise heights calculation, items that were in buffer once\r\n      let topPaddingHeight = topPadding.cache.reduce((summ, item) => summ + (item.index < buffer.first ? item.height : 0), 0);\r\n      let bottomPaddingHeight = bottomPadding.cache.reduce((summ, item) => summ + (item.index >= buffer.next ? item.height : 0), 0);\r\n\r\n      // average item height based on buffer data\r\n      let visibleItemsHeight = buffer.reduce((summ, item) => summ + item.element.outerHeight(true), 0);\r\n      let averageItemHeight = (visibleItemsHeight + topPaddingHeight + bottomPaddingHeight) / (buffer.maxIndex - buffer.minIndex + 1);\r\n\r\n      // average heights calculation, items that have never been reached\r\n      let adjustTopPadding = buffer.minIndexUser !== null && buffer.minIndex > buffer.minIndexUser;\r\n      let adjustBottomPadding = buffer.maxIndexUser !== null && buffer.maxIndex < buffer.maxIndexUser;\r\n      let topPaddingHeightAdd = adjustTopPadding ? (buffer.minIndex - buffer.minIndexUser) * averageItemHeight : 0;\r\n      let bottomPaddingHeightAdd = adjustBottomPadding ? (buffer.maxIndexUser - buffer.maxIndex) * averageItemHeight : 0;\r\n\r\n      // paddings combine adjustment\r\n      topPadding.height(topPaddingHeight + topPaddingHeightAdd);\r\n      bottomPadding.height(bottomPaddingHeight + bottomPaddingHeightAdd);\r\n    },\r\n\r\n    adjustScrollTopAfterMinIndexSet(topPaddingHeightOld) {\r\n      // additional scrollTop adjustment in case of datasource.minIndex external set\r\n      if (buffer.minIndexUser !== null && buffer.minIndex > buffer.minIndexUser) {\r\n        let diff = topPadding.height() - topPaddingHeightOld;\r\n        viewport.scrollTop(viewport.scrollTop() + diff);\r\n      }\r\n    },\r\n\r\n    adjustScrollTopAfterPrepend(updates) {\r\n      if (!updates.prepended.length)\r\n        return;\r\n      const height = buffer.effectiveHeight(updates.prepended);\r\n      const paddingHeight = topPadding.height() - height;\r\n      if (paddingHeight >= 0) {\r\n        topPadding.height(paddingHeight);\r\n      }\r\n      else {\r\n        topPadding.height(0);\r\n        viewport.scrollTop(viewport.scrollTop() - paddingHeight);\r\n      }\r\n    },\r\n\r\n    resetTopPadding() {\r\n      topPadding.height(0);\r\n      topPadding.cache.clear();\r\n    },\r\n\r\n    resetBottomPadding() {\r\n      bottomPadding.height(0);\r\n      bottomPadding.cache.clear();\r\n    }\r\n  });\r\n\r\n  return viewport;\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/modules/viewport.js","function Cache() {\r\n  const cache = Object.create(Array.prototype);\r\n\r\n  angular.extend(cache, {\r\n    add(item) {\r\n      for (let i = cache.length - 1; i >= 0; i--) {\r\n        if (cache[i].index === item.scope.$index) {\r\n          cache[i].height = item.element.outerHeight();\r\n          return;\r\n        }\r\n      }\r\n      cache.push({\r\n        index: item.scope.$index,\r\n        height: item.element.outerHeight()\r\n      });\r\n    },\r\n    clear() {\r\n      cache.length = 0;\r\n    }\r\n  });\r\n\r\n  return cache;\r\n}\r\n\r\nexport default function Padding(template) {\r\n  let result;\r\n\r\n  switch (template.tagName) {\r\n    case 'dl':\r\n      throw new Error(`ui-scroll directive does not support <${template.tagName}> as a repeating tag: ${template.outerHTML}`);\r\n    case 'tr':\r\n      let table = angular.element('<table><tr><td><div></div></td></tr></table>');\r\n      result = table.find('tr');\r\n      break;\r\n    case 'li':\r\n      result = angular.element('<li></li>');\r\n      break;\r\n    default:\r\n      result = angular.element('<div></div>');\r\n  }\r\n\r\n  result.cache = new Cache();\r\n\r\n  return result;\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/modules/padding.js","export default function Adapter($rootScope, $parse, $attr, viewport, buffer, adjustBuffer, element) {\r\n  const viewportScope = viewport.scope() || $rootScope;\r\n  let disabled = false;\r\n  let self = this;\r\n\r\n  createValueInjector('adapter')(self);\r\n  let topVisibleInjector = createValueInjector('topVisible');\r\n  let topVisibleElementInjector = createValueInjector('topVisibleElement');\r\n  let topVisibleScopeInjector = createValueInjector('topVisibleScope');\r\n  let isLoadingInjector = createValueInjector('isLoading');\r\n\r\n  // Adapter API definition\r\n\r\n  Object.defineProperty(this, 'disabled', {\r\n    get: () => disabled,\r\n    set: (value) => (!(disabled = value)) ? adjustBuffer() : null\r\n  });\r\n\r\n  this.isLoading = false;\r\n  this.isBOF = () => buffer.bof;\r\n  this.isEOF = () => buffer.eof;\r\n  this.isEmpty = () => !buffer.length;\r\n\r\n  this.applyUpdates = (arg1, arg2) => {\r\n    if (angular.isFunction(arg1)) {\r\n      // arg1 is the updater function, arg2 is ignored\r\n      buffer.slice(0).forEach((wrapper) => {\r\n        // we need to do it on the buffer clone, because buffer content\r\n        // may change as we iterate through\r\n        applyUpdate(wrapper, arg1(wrapper.item, wrapper.scope, wrapper.element));\r\n      });\r\n    } else {\r\n      // arg1 is item index, arg2 is the newItems array\r\n      if (arg1 % 1 !== 0) {// checking if it is an integer\r\n        throw new Error('applyUpdates - ' + arg1 + ' is not a valid index');\r\n      }\r\n\r\n      const index = arg1 - buffer.first;\r\n      if ((index >= 0 && index < buffer.length)) {\r\n        applyUpdate(buffer[index], arg2);\r\n      }\r\n    }\r\n\r\n    adjustBuffer();\r\n  };\r\n\r\n  this.append = (newItems) => {\r\n    buffer.append(newItems);\r\n    adjustBuffer();\r\n  };\r\n\r\n  this.prepend = (newItems) => {\r\n    buffer.prepend(newItems);\r\n    adjustBuffer();\r\n  };\r\n\r\n  this.loading = (value) => {\r\n    isLoadingInjector(value);\r\n  };\r\n\r\n  this.calculateProperties = () => {\r\n    let item, itemHeight, itemTop, isNewRow, rowTop = null;\r\n    let topHeight = 0;\r\n    for (let i = 0; i < buffer.length; i++) {\r\n      item = buffer[i];\r\n      itemTop = item.element.offset().top;\r\n      isNewRow = rowTop !== itemTop;\r\n      rowTop = itemTop;\r\n      if (isNewRow) {\r\n        itemHeight = item.element.outerHeight(true);\r\n      }\r\n      if (isNewRow && (viewport.topDataPos() + topHeight + itemHeight <= viewport.topVisiblePos())) {\r\n        topHeight += itemHeight;\r\n      } else {\r\n        if (isNewRow) {\r\n          topVisibleInjector(item.item);\r\n          topVisibleElementInjector(item.element);\r\n          topVisibleScopeInjector(item.scope);\r\n        }\r\n        break;\r\n      }\r\n    }\r\n  };\r\n\r\n  // private function definitions\r\n\r\n  function createValueInjector(attribute) {\r\n    let expression = $attr[attribute];\r\n    let scope = viewportScope;\r\n    let assign;\r\n    if (expression) {\r\n      // it is ok to have relaxed validation for the first part of the 'on' expression.\r\n      // additional validation will be done by the $parse service below\r\n      let match = expression.match(/^(\\S+)(?:\\s+on\\s+(\\w(?:\\w|\\d)*))?/);\r\n      if (!match)\r\n        throw new Error('Expected injection expression in form of \\'target\\' or \\'target on controller\\' but got \\'' + expression + '\\'');\r\n      let target = match[1];\r\n      let onControllerName = match[2];\r\n\r\n      let parseController = (controllerName, on) => {\r\n        let candidate = element;\r\n        while (candidate.length) {\r\n          let candidateScope = candidate.scope();\r\n          // ng-controller's \"Controller As\" parsing\r\n          let candidateName = (candidate.attr('ng-controller') || '').match(/(\\w(?:\\w|\\d)*)(?:\\s+as\\s+(\\w(?:\\w|\\d)*))?/);\r\n          if (candidateName && candidateName[on ? 1 : 2] === controllerName) {\r\n            scope = candidateScope;\r\n            return true;\r\n          }\r\n          // directive's/component's \"Controller As\" parsing\r\n          if (!on && candidateScope && candidateScope.hasOwnProperty(controllerName) && Object.getPrototypeOf(candidateScope[controllerName]).constructor.hasOwnProperty('$inject')) {\r\n            scope = candidateScope;\r\n            return true;\r\n          }\r\n          candidate = candidate.parent();\r\n        }\r\n      };\r\n\r\n      if (onControllerName) { // 'on' syntax DOM parsing (adapter=\"adapter on ctrl\")\r\n        scope = null;\r\n        parseController(onControllerName, true);\r\n        if (!scope) {\r\n          throw new Error('Failed to locate target controller \\'' + onControllerName + '\\' to inject \\'' + target + '\\'');\r\n        }\r\n      }\r\n      else { // try to parse DOM with 'Controller As' syntax (adapter=\"ctrl.adapter\")\r\n        let controllerAsName;\r\n        let dotIndex = target.indexOf('.');\r\n        if (dotIndex > 0) {\r\n          controllerAsName = target.substr(0, dotIndex);\r\n          parseController(controllerAsName, false);\r\n        }\r\n      }\r\n\r\n      assign = $parse(target).assign;\r\n    }\r\n    return (value) => {\r\n      if (self !== value) // just to avoid injecting adapter reference in the adapter itself. Kludgy, I know.\r\n        self[attribute] = value;\r\n      if (assign)\r\n        assign(scope, value);\r\n    };\r\n  }\r\n\r\n  function applyUpdate(wrapper, newItems) {\r\n    if (!angular.isArray(newItems)) {\r\n      return;\r\n    }\r\n\r\n    let keepIt;\r\n    let pos = (buffer.indexOf(wrapper)) + 1;\r\n\r\n    newItems.reverse().forEach((newItem) => {\r\n      if (newItem === wrapper.item) {\r\n        keepIt = true;\r\n        pos--;\r\n      } else {\r\n        buffer.insert(pos, newItem);\r\n      }\r\n    });\r\n\r\n    if (!keepIt) {\r\n      wrapper.op = 'remove';\r\n    }\r\n  }\r\n\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/modules/adapter.js"],"sourceRoot":""}